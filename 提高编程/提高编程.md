本阶段主要针对C++ **泛型编程** 和 **STL技术** 做详细讲解，探讨C++更深层的使用。

# 1 模板

模板的特点：

- 不可以直接使用，只是一个框架；
- 模板的通用并不是万能的；

C++另一种编程思想称为 **泛型编程**，主要利用的技术就是模板。C++提供两种模板机制：

- 函数模板
- 类模板

## 1.1 函数模板

### 1.1.1 基本使用

函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个 **虚拟的类型** 来代表。

语法：

```c++
template<typename T>
函数声明或定义
```

解释：

- `template`：声明创建模板；
- `typename`：表明其后面的符号是一个通用的数据类型，可以用 `class` 代替；
- `T`：通用的数据类型，名称可以替换，通常为大写字母；

实例：

```c++
void swapInt(int & a, int & b){
    int tmp = a;
    a = b;
    b = tmp;
}

void swapDouble(double & a, double & b){
    double tmp = a;
    a = b;
    b = tmp;
}
```

上面是两个不同类型的交换函数，这两个函数除了函数名之后唯一的区别就是类型不同，因此 **如果可以不指定类型，后续根据需要传入** 就可以简化代码。

```c++
template<typename T>
void mySwap(T & a, T & b){
    T tmp = a;
    a = b;
    b = tmp;
}
int a = 10;
int b = 20;
double c = 1.1;
double d = 2.2;
mySwap(a, b);  // 自动类型推导
mySwap<double>(c, d);  // 显示指定类型
```

总结：

- 函数的模板使用有两种方式：自动类型推导、显示指定类型；
- 模板的目的是为了提高复用性，将类型参数化；
- `typename` 和 `class` 作用一样，没有区别，不过一般是函数模板用 `typename`，类模板用 `class`；

### 1.1.2 注意事项

注意事项1：自动类型推导必须推导出一致的数据类型 `T` 才可以使用。

```c++
int a = 10;
double c = 1.1;
mySwap(a, c);
```

报错：deduced conflicting types for parameter 'T' ('int' and 'double')。意思是 `T` 的推导发生了冲突，不知道是 `int` 还是 `double`。

注意事项2：模板必须要确定出 `T` 的数据类型才可以使用；

```c++
template<typename T>
void func(){
    cout << "hello world" << endl;
}

int main(){
    func();
}
```

报错：couldn't deduce template parameter 'T'。意思是推导不出 `T` 的数据类型。

注意事项3：`template` 和函数定义（声明）之间不能存在有效语句（注释可以存在）

```c++
// 可以
template<typename T>
bool isSame(T a, T b){
    if (a == b){
        cout << "函数模板";
        return true;
    }
    return false;
}

// 可以
template<typename T>
// void func();
bool isSame(T a, T b){
    if (a == b){
        cout << "函数模板";
        return true;
    }
    return false;
}

// 不可以
template<typename T>
void func();
bool isSame(T a, T b){
    if (a == b){
        cout << "函数模板";
        return true;
    }
    return false;
}
```

注意事项4：函数声明和定义如果分开，两个地方都要写 `template<typename T>`。



### 1.1.3 案例

案例描述：

- 利用函数模板封装一个排序的函数，可以对 **不同数据类型数据** 进行排序；
- 排序规则从大到小，排序算法为 **选择排序**；
- 分别利用 `char` 数据 和 `int` 数据进行测试；

```c++
#include <iostream>
using namespace std;

template<typename T>
void mySwap(T & a, T & b){
    T tmp = a;
    a = b;
    b = tmp;
}

template<typename T>
void mySort(T arr[], int len){
    for (int i = 0; i < len - 1; i++){
        int maxIdx = i;
        for (int j = i + 1; j < len; j++){
            if (arr[maxIdx] < arr [j]){
                maxIdx = j;
            }
        }
        if (maxIdx != i) {
            mySwap(arr[i], arr[maxIdx]);
        }
    }
}

template<typename T>
void printArr(T arr[], int len){
    for (int i = 0; i < len; i ++){
        cout << arr[i] << '\t';
    }
    cout << endl;
}


int main(){
    char charArr[] = "asdfhe";
    int intArr[] = {1, 4, 6, 8, 9, 2};
    int charArrLen = sizeof(charArr) / sizeof(charArr[0]);
    int intArrLen = sizeof(intArr) / sizeof(intArr[0]);
    mySort(charArr, charArrLen);
    mySort(intArr, intArrLen);
    printArr(charArr, charArrLen);
    printArr(intArr, intArrLen);
}

```

![image-20241016232012690](提高编程_pictures/image-20241016232012690.png)

### 1.1.4 普通函数与函数模板的区别

两者的区别：

- 普通函数调用时可以发生自动类型转换（隐式类型转换）；
- 函数模板调用时，如果利用自动类型推导，则不会发生隐式类型转换；
- 如果利用显示指定类型的方式，可以发生隐式类型转换；

```c++
#include <iostream>
using namespace std;

int myAdd01(int a, int b){
    return a + b;
}

template<typename T>
int myAdd02(T a, T b){
    return a + b;
}

int main(){
    int a = 10;
    int b = 20;
    char c = 'a';
    cout << "普通函数调用，传入 int a 和 int b：" << myAdd01(a, b) << endl;
    cout << "普通函数调用，传入 int a 和 char c：" << myAdd01(a, c) << endl;
    cout << "函数模板调用（自动类型推导），传入 int a 和 int b：" << myAdd02(a ,b) << endl;
//    cout << "函数模板调用（自动类型推导），传入 int a 和 char c：" << myAdd02(a ,c) << endl;
    cout << "函数模板调用（显示指定类型），传入 int a 和 int b：" << myAdd02<int>(a ,b) << endl;
    cout << "函数模板调用（显示指定类型），传入 int a 和 char c：" << myAdd02<int>(a ,c) << endl;

    return 0;
}
```

![image-20241017220723239](提高编程_pictures/image-20241017220723239.png)

解释：

- 这里 `c` 能够相加是因为被转为了 `int` 型，本质上其实 `char` 存入内存的就是 ASCII 码，`char` 只是显示的方式，所以只能 `int` 和 `char` 互相转换；
- 普通函数调用，会自动完成 `char` 到 `int` 的转变；
- 函数模板调用，不会自动完成 `char` 到 `int` 的转变，需要显示指定类型；

总结：

- 建议使用显示指定的方式调用模板函数；

### 1.1.5 普通函数与函数模板的调用规则

调用规则如下：

1. 如果函数模板和普通函数都可以实现，优先调用普通函数；
2. 可以通过 **空模板参数列表** 来强制调用函数模板；
3. 函数模板也可以发生重载；
4. 如果函数模板可以产生更好的匹配，优先调用函数模板；

```c++
void myPrint(int a){
    cout << "普通函数：" << a << endl;
}

template<typename T>
void myPrint(T a){
    cout << "函数模板：" << a << endl;
}
```

调用函数：

```c++
int a = 10;
myPrint(a);
```

结果是调用了普通函数，这就说明了调用规则的第一点。即使普通函数只有声明而没有实现，也会调用普通函数，从而导致报错。

如果希望调用函数模板，可以使用这样的方式：

```c++
int a = 10;
myPrint<>(a);
```

这就是 **空模板参数列表**。

如果是如下的调用方式：

```c++
char c = 'b';
myPrint(c);
```

也是调用的函数模板，因为普通函数要求传入 `int` ，这里传入 `char`，虽然可以互相转换，但函数模板更加匹配，它可以直接传入 `char`，所以调用函数模板。

最后，函数模板也可以发生重载：

```c++
template<typename T>
void myPrint(T a){
    cout << "函数模板：" << a << endl;
}

template<typename T>
void myPrint(T a, T b){
    cout << "函数模板：" << a << ", " << b <<endl;
}
```

### 1.1.6 模板的局限性

假设存在如下模板：

```c++
template<typename T>
bool isSame(T & a, T & b){
    if (a == b){
        return true;
    }
    return false;
}
```

如果传入的 `a` 和 `b` 是数组或者自定以的类则无法比较。

为了解决上述问题，C++提供模板的重载，可以为这些特定的类型提供具体化模板。

```c++
template<typename T>
bool isSame(T & a, T & b){
    if (a == b){
        return true;
    }
    return false;
}

// 具体化模板
template<> bool isSame(Person & a, Person & b){
    if (a.m_Name == b.m_Name && a.m_Age == b.m_Age){
        return true;
    }
    return false;
}
```

需要注意：

- 模板参数列表是什么样子，下面也得是什么样子，比如不能少了引用或者用其他的；
- 具体化模板与普通函数的区别，具体化模板就像是函数模板的一个实例，而普通函数和函数模板就是两个不一样的东西了；



总结：

- 利用具体化模板可以解决自定义类型的通用化；
- 学习模板并不是为了写模板，而是在 STL 能够运用系统提供的模板；



## 1.2 类模板

### 1.2.1 语法

类模板作用：建立一个通用类，类中的成员、数据类型可以不具体制定，用一个 **虚拟的类型** 来代表。

语法：

```c++
template<class T>
类的定义
```

例子：

```c++
#include <iostream>
using namespace std;

template<typename NameType, typename AgeType>
class Person{
public:
    Person(NameType name, AgeType age){
        m_Name = name;
        m_Age = age;
    }

    void showPerson(){
        cout << "姓名：" << this->m_Name << endl;
        cout << "年龄：" << this->m_Age << endl;
    }

    NameType m_Name;
    AgeType m_Age;
};


int main(){
    Person<string, int> p("Tom", 18); 
    // Person<string, int>p("Tom", 18); // 也可以
    p.showPerson();
    
    return 0;
}

```

![image-20241017230542018](提高编程_pictures/image-20241017230542018.png)



# 2 STL 初识



# 3 STL - 常用容器



# 4 STL - 函数对象



# 5 STL - 常用算法

